/*
* Kinova Gen3 Trajectory Executor
* Executes a densified 1000Hz trajectory on Kinova Gen3 7DoF arm
*/

#include <iostream>
#include <string>
#include <vector>
#include <math.h>
#include <algorithm>
#include <limits>
#include <iomanip>
#include <thread>
#include <chrono>

#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#ifndef _OS_UNIX
#define _OS_UNIX
#endif

#include <gtsam/geometry/Pose3.h>
#include <gtsam/geometry/Point3.h>
#include <gtsam/geometry/Rot3.h>
#include <gtsam/base/Vector.h>
#include <gtsam/nonlinear/Values.h>

#include <KDetailedException.h>
#include <BaseClientRpc.h>
#include <BaseCyclicClientRpc.h>
#include <SessionClientRpc.h>
#include <SessionManager.h>
#include <RouterClient.h>
#include <TransportClientUdp.h>
#include <TransportClientTcp.h>

#include <google/protobuf/util/json_util.h>

#if defined(_MSC_VER)
#include <Windows.h>
#else
#include <unistd.h>
#endif
#include <time.h>

namespace k_api = Kinova::Api;

#define PORT 10000
#define PORT_REAL_TIME 10001

class JointPositionTrajectoryExecutor {
private:


public:

    // Get current time in microseconds
    int64_t GetTickUs() {
    #if defined(_MSC_VER)
        LARGE_INTEGER start, frequency;
        QueryPerformanceFrequency(&frequency);
        QueryPerformanceCounter(&start);
        return (start.QuadPart * 1000000) / frequency.QuadPart;
    #else
        struct timespec start;
        clock_gettime(CLOCK_MONOTONIC, &start);
        return (start.tv_sec * 1000000LLU) + (start.tv_nsec / 1000);
    #endif
    }

    std::vector<double> getCurrentJointPositions(k_api::Base::BaseClient* base) {
        std::vector<double> positions;
        try {
            auto joint_angles = base->GetMeasuredJointAngles();
            for (const auto& joint_angle : joint_angles.joint_angles()) {
                positions.push_back(joint_angle.value());
            }
        } catch (const std::exception& e) {
            std::cout << "Error reading joint positions: " << e.what() << std::endl;
        }
        return positions;
    }
    

    // Create an event listener that will set the promise action event to the exit value
    // Will set to either END or ABORT
    std::function<void(k_api::Base::ActionNotification)> 
        create_action_event_listener_by_promise(std::promise<k_api::Base::ActionEvent>& finish_promise)
    {
        return [&finish_promise] (k_api::Base::ActionNotification notification)
        {
            const auto action_event = notification.action_event();
            switch(action_event)
            {
            case k_api::Base::ActionEvent::ACTION_END:
            case k_api::Base::ActionEvent::ACTION_ABORT:
                finish_promise.set_value(action_event);
                break;
            default:
                break;
            }
        };
    }

    // Move to trajectory start position safely
    bool moveToTrajectoryStart(k_api::Base::BaseClient* base, 
                              const std::vector<double>& trajectory_start) {

        std::cout << "Moving to trajectory start position..." << std::endl;

        try {
            base->ClearFaults();
        } catch(...) {
            std::cout << "Unable to clear robot faults" << std::endl;
            return false;
        }

        // Set high-level servoing mode
        auto servoing_mode = k_api::Base::ServoingModeInformation();
        servoing_mode.set_servoing_mode(k_api::Base::ServoingMode::SINGLE_LEVEL_SERVOING);
        base->SetServoingMode(servoing_mode);
        std::this_thread::sleep_for(std::chrono::milliseconds(500));
        
        // Create joint angle action
        auto constrained_joint_angles = k_api::Base::ConstrainedJointAngles();
        auto joint_angles = constrained_joint_angles.mutable_joint_angles();
        
        for(size_t i = 0; i < trajectory_start.size(); i++) {
            auto joint_angle = joint_angles->add_joint_angles();
            joint_angle->set_joint_identifier(i);
            joint_angle->set_value(trajectory_start[i]);
        }
        
        // Connect to notification action topic
        std::promise<k_api::Base::ActionEvent> promise;
        auto future = promise.get_future();
        auto notification_handle = base->OnNotificationActionTopic(
            create_action_event_listener_by_promise(promise),
            k_api::Common::NotificationOptions{}
        );
        
        // Execute movement
        std::cout << "Executing movement to start position..." << std::endl;
        base->PlayJointTrajectory(constrained_joint_angles);
        
        // Wait for action to finish
        constexpr auto TIMEOUT_DURATION = std::chrono::seconds(20);
        const auto status = future.wait_for(TIMEOUT_DURATION);
        base->Unsubscribe(notification_handle);
        
        if (status != std::future_status::ready) {
            std::cout << "Timeout on action notification wait" << std::endl;
            return false;
        }
        
        const auto action_event = future.get();
        if (action_event != k_api::Base::ActionEvent::ACTION_END) {
            std::cout << "Movement failed with event: " << k_api::Base::ActionEvent_Name(action_event) << std::endl;
            return false;
        }
        
        std::cout << "Reached trajectory start position" << std::endl;
        return true;
    }
    

    // Main trajectory execution function
    bool executeTrajectory(const std::vector<std::vector<double>>& trajectory,
                        k_api::Base::BaseClient* base,
                        k_api::BaseCyclic::BaseCyclicClient* base_cyclic) {
    
    std::cout << "Starting trajectory execution..." << std::endl;
    std::cout << "Trajectory length: " << trajectory.size() << " points" << std::endl;
    
    // Move to start position
    if(!moveToTrajectoryStart(base, trajectory[0])) {
        std::cout << "Failed to reach trajectory start position" << std::endl;
        return false;
    }
    
    // Clear any faults
    try {
        base->ClearFaults();
    } catch(...) {
        std::cout << "Unable to clear robot faults" << std::endl;
        return false;
    }
    
    // Set to low-level servoing mode
    auto servoing_mode = k_api::Base::ServoingModeInformation();
    servoing_mode.set_servoing_mode(k_api::Base::ServoingMode::LOW_LEVEL_SERVOING);
    base->SetServoingMode(servoing_mode);
    
    // Initialize cyclic communication
    k_api::BaseCyclic::Feedback base_feedback;
    k_api::BaseCyclic::Command base_command;
    
    base_feedback = base_cyclic->RefreshFeedback();
    
    // Initialize command with current positions
    for(int i = 0; i < 7; i++) {
        base_command.add_actuators()->set_position(base_feedback.actuators(i).position());
    }
    
    // Send initial frame
    base_feedback = base_cyclic->Refresh(base_command);
    
    std::cout << "Starting trajectory execution..." << std::endl;
    
    // Real-time execution loop - using official Kinova timing pattern
    int trajectory_idx = 0;
    int64_t now = 0;
    int64_t last = 0;
    
    while(trajectory_idx < trajectory.size()) {
        now = GetTickUs();
        
        // Check if 1ms has passed (1000 microseconds) - using official pattern
        if(now - last > 1000) {
            
            // Set joint positions from trajectory
            for(int i = 0; i < 7; i++) {
                base_command.mutable_actuators(i)->set_position(trajectory[trajectory_idx][i]);
            }
            
            // Update frame ID
            base_command.set_frame_id(base_command.frame_id() + 1);
            if(base_command.frame_id() > 65535) {
                base_command.set_frame_id(0);
            }
            
            // Set command IDs
            for(int i = 0; i < 7; i++) {
                base_command.mutable_actuators(i)->set_command_id(base_command.frame_id());
            }
            
            try {
                base_feedback = base_cyclic->Refresh(base_command, 0);
            } catch(k_api::KDetailedException& ex) {
                std::cout << "Kortex exception during trajectory execution: " << ex.what() << std::endl;
                break;
            } catch(std::runtime_error& ex) {
                std::cout << "Runtime error during trajectory execution: " << ex.what() << std::endl;
                break;
            } catch(...) {
                std::cout << "Unknown error during trajectory execution" << std::endl;
                break;
            }
            
            trajectory_idx++;
            last = GetTickUs();  // CRITICAL: Set AFTER communication, not before
            
            // Progress indicator
            if(trajectory_idx % 100 == 0) {
                double progress = (double)trajectory_idx / trajectory.size() * 100.0;
                std::cout << "Progress: " << std::fixed << std::setprecision(1) << progress << "%" << std::endl;
            }
        }
    }
    
    std::cout << "Trajectory execution completed!" << std::endl;
    
    // Return to high-level servoing
    servoing_mode.set_servoing_mode(k_api::Base::ServoingMode::SINGLE_LEVEL_SERVOING);
    base->SetServoingMode(servoing_mode);
    
    return true;
    }
};

// Example usage function
bool runTrajectory(const std::string& ip_address, const std::vector<std::vector<double>>& trajectory) {
    
    // Create API objects (similar to your examples)
    auto error_callback = [](k_api::KError err){ 
        std::cout << "API Error: " << err.toString() << std::endl; 
    };
    
    // TCP connection for configuration
    auto transport = new k_api::TransportClientTcp();
    auto router = new k_api::RouterClient(transport, error_callback);
    transport->connect(ip_address, PORT);
    
    // UDP connection for real-time control
    auto transport_real_time = new k_api::TransportClientUdp();
    auto router_real_time = new k_api::RouterClient(transport_real_time, error_callback);
    transport_real_time->connect(ip_address, PORT_REAL_TIME);
    
    // Session setup
    auto create_session_info = k_api::Session::CreateSessionInfo();
    create_session_info.set_username("admin");
    create_session_info.set_password("admin");
    create_session_info.set_session_inactivity_timeout(60000);
    create_session_info.set_connection_inactivity_timeout(2000);
    
    auto session_manager = new k_api::SessionManager(router);
    session_manager->CreateSession(create_session_info);
    auto session_manager_real_time = new k_api::SessionManager(router_real_time);
    session_manager_real_time->CreateSession(create_session_info);
    
    // Create service clients
    auto base = new k_api::Base::BaseClient(router);
    auto base_cyclic = new k_api::BaseCyclic::BaseCyclicClient(router_real_time);

    // Execute trajectory
    JointPositionTrajectoryExecutor executor;
    bool success = executor.executeTrajectory(trajectory, base, base_cyclic);
    
    // Cleanup
    session_manager->CloseSession();
    session_manager_real_time->CloseSession();
    
    router->SetActivationStatus(false);
    transport->disconnect();
    router_real_time->SetActivationStatus(false);
    transport_real_time->disconnect();
    
    // Delete objects
    delete base;
    delete base_cyclic;
    delete session_manager;
    delete session_manager_real_time;
    delete router;
    delete router_real_time;
    delete transport;
    delete transport_real_time;
    
    return success;
}
